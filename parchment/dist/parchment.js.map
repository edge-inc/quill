{"version":3,"file":"parchment.js","mappings":"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","sources":["webpack://Parchment/webpack/universalModuleDefinition","webpack://Parchment/webpack/bootstrap","webpack://Parchment/./src/scope.ts","webpack://Parchment/webpack/runtime/define property getters","webpack://Parchment/webpack/runtime/hasOwnProperty shorthand","webpack://Parchment/webpack/runtime/make namespace object","webpack://Parchment/./src/error.ts","webpack://Parchment/./src/registry.ts","webpack://Parchment/./src/blot/abstract/shadow.ts","webpack://Parchment/./src/blot/abstract/parent.ts","webpack://Parchment/./src/collection/linked-list.ts","webpack://Parchment/./src/blot/abstract/container.ts","webpack://Parchment/./src/blot/abstract/leaf.ts","webpack://Parchment/./src/attributor/attributor.ts","webpack://Parchment/./src/attributor/class.ts","webpack://Parchment/./src/attributor/style.ts","webpack://Parchment/./src/attributor/store.ts","webpack://Parchment/./src/blot/inline.ts","webpack://Parchment/./src/blot/block.ts","webpack://Parchment/./src/blot/embed.ts","webpack://Parchment/./src/blot/scroll.ts","webpack://Parchment/./src/blot/text.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Parchment\"] = factory();\n\telse\n\t\troot[\"Parchment\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","var Scope;\n(function (Scope) {\n    Scope[Scope[\"TYPE\"] = 3] = \"TYPE\";\n    Scope[Scope[\"LEVEL\"] = 12] = \"LEVEL\";\n    Scope[Scope[\"ATTRIBUTE\"] = 13] = \"ATTRIBUTE\";\n    Scope[Scope[\"BLOT\"] = 14] = \"BLOT\";\n    Scope[Scope[\"INLINE\"] = 7] = \"INLINE\";\n    Scope[Scope[\"BLOCK\"] = 11] = \"BLOCK\";\n    Scope[Scope[\"BLOCK_BLOT\"] = 10] = \"BLOCK_BLOT\";\n    Scope[Scope[\"INLINE_BLOT\"] = 6] = \"INLINE_BLOT\";\n    Scope[Scope[\"BLOCK_ATTRIBUTE\"] = 9] = \"BLOCK_ATTRIBUTE\";\n    Scope[Scope[\"INLINE_ATTRIBUTE\"] = 5] = \"INLINE_ATTRIBUTE\";\n    Scope[Scope[\"ANY\"] = 15] = \"ANY\";\n})(Scope || (Scope = {}));\nexport default Scope;\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export default class ParchmentError extends Error {\n    constructor(message) {\n        message = '[Parchment] ' + message;\n        super(message);\n        this.message = message;\n        this.name = this.constructor.name;\n    }\n}\n","import ParchmentError from './error';\nimport Scope from './scope';\nexport default class Registry {\n    constructor() {\n        this.attributes = {};\n        this.classes = {};\n        this.tags = {};\n        this.types = {};\n    }\n    static find(node, bubble = false) {\n        if (node == null) {\n            return null;\n        }\n        if (this.blots.has(node)) {\n            return this.blots.get(node) || null;\n        }\n        if (bubble) {\n            return this.find(node.parentNode, bubble);\n        }\n        return null;\n    }\n    create(scroll, input, value) {\n        const match = this.query(input);\n        if (match == null) {\n            throw new ParchmentError(`Unable to create ${input} blot`);\n        }\n        const blotClass = match;\n        const node = \n        // @ts-ignore\n        input instanceof Node || input.nodeType === Node.TEXT_NODE\n            ? input\n            : blotClass.create(value);\n        const blot = new blotClass(scroll, node, value);\n        Registry.blots.set(blot.domNode, blot);\n        return blot;\n    }\n    find(node, bubble = false) {\n        return Registry.find(node, bubble);\n    }\n    query(query, scope = Scope.ANY) {\n        let match;\n        if (typeof query === 'string') {\n            match = this.types[query] || this.attributes[query];\n            // @ts-ignore\n        }\n        else if (query instanceof Text || query.nodeType === Node.TEXT_NODE) {\n            match = this.types.text;\n        }\n        else if (typeof query === 'number') {\n            if (query & Scope.LEVEL & Scope.BLOCK) {\n                match = this.types.block;\n            }\n            else if (query & Scope.LEVEL & Scope.INLINE) {\n                match = this.types.inline;\n            }\n        }\n        else if (query instanceof HTMLElement) {\n            const names = (query.getAttribute('class') || '').split(/\\s+/);\n            names.some((name) => {\n                match = this.classes[name];\n                if (match) {\n                    return true;\n                }\n                return false;\n            });\n            match = match || this.tags[query.tagName];\n        }\n        if (match == null) {\n            return null;\n        }\n        // @ts-ignore\n        if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope) {\n            return match;\n        }\n        return null;\n    }\n    register(...definitions) {\n        if (definitions.length > 1) {\n            return definitions.map((d) => {\n                return this.register(d);\n            });\n        }\n        const definition = definitions[0];\n        if (typeof definition.blotName !== 'string' &&\n            typeof definition.attrName !== 'string') {\n            throw new ParchmentError('Invalid definition');\n        }\n        else if (definition.blotName === 'abstract') {\n            throw new ParchmentError('Cannot register abstract class');\n        }\n        this.types[definition.blotName || definition.attrName] = definition;\n        if (typeof definition.keyName === 'string') {\n            this.attributes[definition.keyName] = definition;\n        }\n        else {\n            if (definition.className != null) {\n                this.classes[definition.className] = definition;\n            }\n            if (definition.tagName != null) {\n                if (Array.isArray(definition.tagName)) {\n                    definition.tagName = definition.tagName.map((tagName) => {\n                        return tagName.toUpperCase();\n                    });\n                }\n                else {\n                    definition.tagName = definition.tagName.toUpperCase();\n                }\n                const tagNames = Array.isArray(definition.tagName)\n                    ? definition.tagName\n                    : [definition.tagName];\n                tagNames.forEach((tag) => {\n                    if (this.tags[tag] == null || definition.className == null) {\n                        this.tags[tag] = definition;\n                    }\n                });\n            }\n        }\n        return definition;\n    }\n}\nRegistry.blots = new WeakMap();\n","import ParchmentError from '../../error';\nimport Registry from '../../registry';\nimport Scope from '../../scope';\nclass ShadowBlot {\n    constructor(scroll, domNode) {\n        this.scroll = scroll;\n        this.domNode = domNode;\n        Registry.blots.set(domNode, this);\n        this.prev = null;\n        this.next = null;\n    }\n    static create(value) {\n        if (this.tagName == null) {\n            throw new ParchmentError('Blot definition missing tagName');\n        }\n        let node;\n        if (Array.isArray(this.tagName)) {\n            if (typeof value === 'string') {\n                value = value.toUpperCase();\n                if (parseInt(value, 10).toString() === value) {\n                    value = parseInt(value, 10);\n                }\n            }\n            if (typeof value === 'number') {\n                node = document.createElement(this.tagName[value - 1]);\n            }\n            else if (this.tagName.indexOf(value) > -1) {\n                node = document.createElement(value);\n            }\n            else {\n                node = document.createElement(this.tagName[0]);\n            }\n        }\n        else {\n            node = document.createElement(this.tagName);\n        }\n        if (this.className) {\n            node.classList.add(this.className);\n        }\n        return node;\n    }\n    // Hack for accessing inherited static methods\n    get statics() {\n        return this.constructor;\n    }\n    attach() {\n        // Nothing to do\n    }\n    clone() {\n        const domNode = this.domNode.cloneNode(false);\n        return this.scroll.create(domNode);\n    }\n    detach() {\n        if (this.parent != null) {\n            this.parent.removeChild(this);\n        }\n        Registry.blots.delete(this.domNode);\n    }\n    deleteAt(index, length) {\n        const blot = this.isolate(index, length);\n        blot.remove();\n    }\n    formatAt(index, length, name, value) {\n        const blot = this.isolate(index, length);\n        if (this.scroll.query(name, Scope.BLOT) != null && value) {\n            blot.wrap(name, value);\n        }\n        else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n            const parent = this.scroll.create(this.statics.scope);\n            blot.wrap(parent);\n            parent.format(name, value);\n        }\n    }\n    insertAt(index, value, def) {\n        const blot = def == null\n            ? this.scroll.create('text', value)\n            : this.scroll.create(value, def);\n        const ref = this.split(index);\n        this.parent.insertBefore(blot, ref || undefined);\n    }\n    isolate(index, length) {\n        const target = this.split(index);\n        if (target == null) {\n            throw new Error('Attempt to isolate at end');\n        }\n        target.split(length);\n        return target;\n    }\n    length() {\n        return 1;\n    }\n    offset(root = this.parent) {\n        if (this.parent == null || this === root) {\n            return 0;\n        }\n        return this.parent.children.offset(this) + this.parent.offset(root);\n    }\n    optimize(_context) {\n        if (this.statics.requiredContainer &&\n            !(this.parent instanceof this.statics.requiredContainer)) {\n            this.wrap(this.statics.requiredContainer.blotName);\n        }\n    }\n    remove() {\n        if (this.domNode.parentNode != null) {\n            this.domNode.parentNode.removeChild(this.domNode);\n        }\n        this.detach();\n    }\n    replaceWith(name, value) {\n        const replacement = typeof name === 'string' ? this.scroll.create(name, value) : name;\n        if (this.parent != null) {\n            this.parent.insertBefore(replacement, this.next || undefined);\n            this.remove();\n        }\n        return replacement;\n    }\n    split(index, _force) {\n        return index === 0 ? this : this.next;\n    }\n    update(_mutations, _context) {\n        // Nothing to do by default\n    }\n    wrap(name, value) {\n        const wrapper = typeof name === 'string'\n            ? this.scroll.create(name, value)\n            : name;\n        if (this.parent != null) {\n            this.parent.insertBefore(wrapper, this.next || undefined);\n        }\n        if (typeof wrapper.appendChild !== 'function') {\n            throw new ParchmentError(`Cannot wrap ${name}`);\n        }\n        wrapper.appendChild(this);\n        return wrapper;\n    }\n}\nShadowBlot.blotName = 'abstract';\nexport default ShadowBlot;\n","import LinkedList from '../../collection/linked-list';\nimport ParchmentError from '../../error';\nimport Scope from '../../scope';\nimport ShadowBlot from './shadow';\nfunction makeAttachedBlot(node, scroll) {\n    let blot = scroll.find(node);\n    if (blot == null) {\n        try {\n            blot = scroll.create(node);\n        }\n        catch (e) {\n            blot = scroll.create(Scope.INLINE);\n            Array.from(node.childNodes).forEach((child) => {\n                // @ts-ignore\n                blot.domNode.appendChild(child);\n            });\n            if (node.parentNode) {\n                node.parentNode.replaceChild(blot.domNode, node);\n            }\n            blot.attach();\n        }\n    }\n    return blot;\n}\nclass ParentBlot extends ShadowBlot {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.uiNode = null;\n        this.build();\n    }\n    appendChild(other) {\n        this.insertBefore(other);\n    }\n    attach() {\n        super.attach();\n        this.children.forEach((child) => {\n            child.attach();\n        });\n    }\n    attachUI(node) {\n        if (this.uiNode != null) {\n            this.uiNode.remove();\n        }\n        this.uiNode = node;\n        if (ParentBlot.uiClass) {\n            this.uiNode.classList.add(ParentBlot.uiClass);\n        }\n        this.uiNode.setAttribute('contenteditable', 'false');\n        this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n    }\n    build() {\n        this.children = new LinkedList();\n        // Need to be reversed for if DOM nodes already in order\n        Array.from(this.domNode.childNodes)\n            .filter((node) => node !== this.uiNode)\n            .reverse()\n            .forEach((node) => {\n            try {\n                const child = makeAttachedBlot(node, this.scroll);\n                this.insertBefore(child, this.children.head || undefined);\n            }\n            catch (err) {\n                if (err instanceof ParchmentError) {\n                    return;\n                }\n                else {\n                    throw err;\n                }\n            }\n        });\n    }\n    deleteAt(index, length) {\n        if (index === 0 && length === this.length()) {\n            return this.remove();\n        }\n        this.children.forEachAt(index, length, (child, offset, childLength) => {\n            child.deleteAt(offset, childLength);\n        });\n    }\n    descendant(criteria, index = 0) {\n        const [child, offset] = this.children.find(index);\n        if ((criteria.blotName == null && criteria(child)) ||\n            (criteria.blotName != null && child instanceof criteria)) {\n            return [child, offset];\n        }\n        else if (child instanceof ParentBlot) {\n            return child.descendant(criteria, offset);\n        }\n        else {\n            return [null, -1];\n        }\n    }\n    descendants(criteria, index = 0, length = Number.MAX_VALUE) {\n        let descendants = [];\n        let lengthLeft = length;\n        this.children.forEachAt(index, length, (child, childIndex, childLength) => {\n            if ((criteria.blotName == null && criteria(child)) ||\n                (criteria.blotName != null && child instanceof criteria)) {\n                descendants.push(child);\n            }\n            if (child instanceof ParentBlot) {\n                descendants = descendants.concat(child.descendants(criteria, childIndex, lengthLeft));\n            }\n            lengthLeft -= childLength;\n        });\n        return descendants;\n    }\n    detach() {\n        this.children.forEach((child) => {\n            child.detach();\n        });\n        super.detach();\n    }\n    enforceAllowedChildren() {\n        let done = false;\n        this.children.forEach((child) => {\n            if (done) {\n                return;\n            }\n            const allowed = this.statics.allowedChildren.some((def) => child instanceof def);\n            if (allowed) {\n                return;\n            }\n            if (child.statics.scope === Scope.BLOCK_BLOT) {\n                if (child.next != null) {\n                    this.splitAfter(child);\n                }\n                if (child.prev != null) {\n                    this.splitAfter(child.prev);\n                }\n                child.parent.unwrap();\n                done = true;\n            }\n            else if (child instanceof ParentBlot) {\n                child.unwrap();\n            }\n            else {\n                child.remove();\n            }\n        });\n    }\n    formatAt(index, length, name, value) {\n        this.children.forEachAt(index, length, (child, offset, childLength) => {\n            child.formatAt(offset, childLength, name, value);\n        });\n    }\n    insertAt(index, value, def) {\n        const [child, offset] = this.children.find(index);\n        if (child) {\n            child.insertAt(offset, value, def);\n        }\n        else {\n            const blot = def == null\n                ? this.scroll.create('text', value)\n                : this.scroll.create(value, def);\n            this.appendChild(blot);\n        }\n    }\n    insertBefore(childBlot, refBlot) {\n        if (childBlot.parent != null) {\n            childBlot.parent.children.remove(childBlot);\n        }\n        let refDomNode = null;\n        this.children.insertBefore(childBlot, refBlot || null);\n        // childBlot.parent = this;\n        if (refBlot != null) {\n            refDomNode = refBlot.domNode;\n        }\n        if (\n        // this.domNode.parentNode !== childBlot.domNode ||\n        // this.domNode.nextSibling !== refDomNode\n        childBlot.domNode.parentNode !== this.domNode ||\n            childBlot.domNode.nextSibling !== refDomNode) {\n            this.domNode.insertBefore(childBlot.domNode, refDomNode);\n        }\n        childBlot.parent = this;\n        childBlot.attach();\n    }\n    length() {\n        return this.children.reduce((memo, child) => {\n            return memo + child.length();\n        }, 0);\n    }\n    moveChildren(targetParent, refNode) {\n        this.children.forEach((child) => {\n            targetParent.insertBefore(child, refNode);\n        });\n    }\n    optimize(context) {\n        super.optimize(context);\n        this.enforceAllowedChildren();\n        if (this.uiNode != null && this.uiNode !== this.domNode.firstChild) {\n            this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n        }\n        if (this.children.length === 0) {\n            if (this.statics.defaultChild != null) {\n                const child = this.scroll.create(this.statics.defaultChild.blotName);\n                this.appendChild(child);\n                // TODO double check if necessary\n                // child.optimize(context);\n            }\n            else {\n                this.remove();\n            }\n        }\n    }\n    path(index, inclusive = false) {\n        const [child, offset] = this.children.find(index, inclusive);\n        const position = [[this, index]];\n        if (child instanceof ParentBlot) {\n            return position.concat(child.path(offset, inclusive));\n        }\n        else if (child != null) {\n            position.push([child, offset]);\n        }\n        return position;\n    }\n    removeChild(child) {\n        this.children.remove(child);\n    }\n    replaceWith(name, value) {\n        const replacement = typeof name === 'string' ? this.scroll.create(name, value) : name;\n        if (replacement instanceof ParentBlot) {\n            this.moveChildren(replacement);\n        }\n        return super.replaceWith(replacement);\n    }\n    split(index, force = false) {\n        if (!force) {\n            if (index === 0) {\n                return this;\n            }\n            if (index === this.length()) {\n                return this.next;\n            }\n        }\n        const after = this.clone();\n        if (this.parent) {\n            this.parent.insertBefore(after, this.next || undefined);\n        }\n        this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n            const split = child.split(offset, force);\n            if (split != null) {\n                after.appendChild(split);\n            }\n        });\n        return after;\n    }\n    splitAfter(child) {\n        const after = this.clone();\n        while (child.next != null) {\n            after.appendChild(child.next);\n        }\n        if (this.parent) {\n            this.parent.insertBefore(after, this.next || undefined);\n        }\n        return after;\n    }\n    unwrap() {\n        if (this.parent) {\n            this.moveChildren(this.parent, this.next || undefined);\n        }\n        this.remove();\n    }\n    update(mutations, _context) {\n        const addedNodes = [];\n        const removedNodes = [];\n        mutations.forEach((mutation) => {\n            if (mutation.target === this.domNode && mutation.type === 'childList') {\n                addedNodes.push(...mutation.addedNodes);\n                removedNodes.push(...mutation.removedNodes);\n            }\n        });\n        removedNodes.forEach((node) => {\n            // Check node has actually been removed\n            // One exception is Chrome does not immediately remove IFRAMEs\n            // from DOM but MutationRecord is correct in its reported removal\n            if (node.parentNode != null &&\n                // @ts-ignore\n                node.tagName !== 'IFRAME' &&\n                document.body.compareDocumentPosition(node) &\n                    Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                return;\n            }\n            const blot = this.scroll.find(node);\n            if (blot == null) {\n                return;\n            }\n            if (blot.domNode.parentNode == null ||\n                blot.domNode.parentNode === this.domNode) {\n                blot.detach();\n            }\n        });\n        addedNodes\n            .filter((node) => {\n            return node.parentNode === this.domNode || node === this.uiNode;\n        })\n            .sort((a, b) => {\n            if (a === b) {\n                return 0;\n            }\n            if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n                return 1;\n            }\n            return -1;\n        })\n            .forEach((node) => {\n            let refBlot = null;\n            if (node.nextSibling != null) {\n                refBlot = this.scroll.find(node.nextSibling);\n            }\n            const blot = makeAttachedBlot(node, this.scroll);\n            if (blot.next !== refBlot || blot.next == null) {\n                if (blot.parent != null) {\n                    blot.parent.removeChild(this);\n                }\n                this.insertBefore(blot, refBlot || undefined);\n            }\n        });\n        this.enforceAllowedChildren();\n    }\n}\nParentBlot.uiClass = '';\nexport default ParentBlot;\n","class LinkedList {\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.length = 0;\n    }\n    append(...nodes) {\n        this.insertBefore(nodes[0], null);\n        if (nodes.length > 1) {\n            const rest = nodes.slice(1);\n            this.append(...rest);\n        }\n    }\n    at(index) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur && index > 0) {\n            index -= 1;\n            cur = next();\n        }\n        return cur;\n    }\n    contains(node) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            if (cur === node) {\n                return true;\n            }\n            cur = next();\n        }\n        return false;\n    }\n    indexOf(node) {\n        const next = this.iterator();\n        let cur = next();\n        let index = 0;\n        while (cur) {\n            if (cur === node) {\n                return index;\n            }\n            index += 1;\n            cur = next();\n        }\n        return -1;\n    }\n    insertBefore(node, refNode) {\n        if (node == null) {\n            return;\n        }\n        this.remove(node);\n        node.next = refNode;\n        if (refNode != null) {\n            node.prev = refNode.prev;\n            if (refNode.prev != null) {\n                refNode.prev.next = node;\n            }\n            refNode.prev = node;\n            if (refNode === this.head) {\n                this.head = node;\n            }\n        }\n        else if (this.tail != null) {\n            this.tail.next = node;\n            node.prev = this.tail;\n            this.tail = node;\n        }\n        else {\n            node.prev = null;\n            this.head = this.tail = node;\n        }\n        this.length += 1;\n    }\n    offset(target) {\n        let index = 0;\n        let cur = this.head;\n        while (cur != null) {\n            if (cur === target) {\n                return index;\n            }\n            index += cur.length();\n            cur = cur.next;\n        }\n        return -1;\n    }\n    remove(node) {\n        if (!this.contains(node)) {\n            return;\n        }\n        if (node.prev != null) {\n            node.prev.next = node.next;\n        }\n        if (node.next != null) {\n            node.next.prev = node.prev;\n        }\n        if (node === this.head) {\n            this.head = node.next;\n        }\n        if (node === this.tail) {\n            this.tail = node.prev;\n        }\n        this.length -= 1;\n    }\n    iterator(curNode = this.head) {\n        // TODO use yield when we can\n        return () => {\n            const ret = curNode;\n            if (curNode != null) {\n                curNode = curNode.next;\n            }\n            return ret;\n        };\n    }\n    find(index, inclusive = false) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            const length = cur.length();\n            if (index < length ||\n                (inclusive &&\n                    index === length &&\n                    (cur.next == null || cur.next.length() !== 0))) {\n                return [cur, index];\n            }\n            index -= length;\n            cur = next();\n        }\n        return [null, 0];\n    }\n    forEach(callback) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            callback(cur);\n            cur = next();\n        }\n    }\n    forEachAt(index, length, callback) {\n        if (length <= 0) {\n            return;\n        }\n        const [startNode, offset] = this.find(index);\n        let curIndex = index - offset;\n        const next = this.iterator(startNode);\n        let cur = next();\n        while (cur && curIndex < index + length) {\n            const curLength = cur.length();\n            if (index > curIndex) {\n                callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));\n            }\n            else {\n                callback(cur, 0, Math.min(curLength, index + length - curIndex));\n            }\n            curIndex += curLength;\n            cur = next();\n        }\n    }\n    map(callback) {\n        return this.reduce((memo, cur) => {\n            memo.push(callback(cur));\n            return memo;\n        }, []);\n    }\n    reduce(callback, memo) {\n        const next = this.iterator();\n        let cur = next();\n        while (cur) {\n            memo = callback(memo, cur);\n            cur = next();\n        }\n        return memo;\n    }\n}\nexport default LinkedList;\n","import Scope from '../../scope';\nimport ParentBlot from './parent';\nclass ContainerBlot extends ParentBlot {\n    checkMerge() {\n        return (this.next !== null && this.next.statics.blotName === this.statics.blotName);\n    }\n    deleteAt(index, length) {\n        super.deleteAt(index, length);\n        this.enforceAllowedChildren();\n    }\n    formatAt(index, length, name, value) {\n        super.formatAt(index, length, name, value);\n        this.enforceAllowedChildren();\n    }\n    insertAt(index, value, def) {\n        super.insertAt(index, value, def);\n        this.enforceAllowedChildren();\n    }\n    optimize(context) {\n        super.optimize(context);\n        if (this.children.length > 0 && this.next != null && this.checkMerge()) {\n            this.next.moveChildren(this);\n            this.next.remove();\n        }\n    }\n}\nContainerBlot.blotName = 'container';\nContainerBlot.scope = Scope.BLOCK_BLOT;\nexport default ContainerBlot;\n","import Scope from '../../scope';\nimport ShadowBlot from './shadow';\nclass LeafBlot extends ShadowBlot {\n    static value(_domNode) {\n        return true;\n    }\n    index(node, offset) {\n        if (this.domNode === node ||\n            this.domNode.compareDocumentPosition(node) &\n                Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return Math.min(offset, 1);\n        }\n        return -1;\n    }\n    position(index, _inclusive) {\n        const childNodes = Array.from(this.parent.domNode.childNodes);\n        let offset = childNodes.indexOf(this.domNode);\n        if (index > 0) {\n            offset += 1;\n        }\n        return [this.parent.domNode, offset];\n    }\n    value() {\n        return {\n            [this.statics.blotName]: this.statics.value(this.domNode) || true,\n        };\n    }\n}\nLeafBlot.scope = Scope.INLINE_BLOT;\nexport default LeafBlot;\n","import Scope from '../scope';\nexport default class Attributor {\n    constructor(attrName, keyName, options = {}) {\n        this.attrName = attrName;\n        this.keyName = keyName;\n        const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n        this.scope =\n            options.scope != null\n                ? // Ignore type bits, force attribute bit\n                    (options.scope & Scope.LEVEL) | attributeBit\n                : Scope.ATTRIBUTE;\n        if (options.whitelist != null) {\n            this.whitelist = options.whitelist;\n        }\n    }\n    static keys(node) {\n        return Array.from(node.attributes).map((item) => item.name);\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        node.setAttribute(this.keyName, value);\n        return true;\n    }\n    canAdd(_node, value) {\n        if (this.whitelist == null) {\n            return true;\n        }\n        if (typeof value === 'string') {\n            return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n        }\n        else {\n            return this.whitelist.indexOf(value) > -1;\n        }\n    }\n    remove(node) {\n        node.removeAttribute(this.keyName);\n    }\n    value(node) {\n        const value = node.getAttribute(this.keyName);\n        if (this.canAdd(node, value) && value) {\n            return value;\n        }\n        return '';\n    }\n}\n","import Attributor from './attributor';\nfunction match(node, prefix) {\n    const className = node.getAttribute('class') || '';\n    return className\n        .split(/\\s+/)\n        .filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\nclass ClassAttributor extends Attributor {\n    static keys(node) {\n        return (node.getAttribute('class') || '')\n            .split(/\\s+/)\n            .map((name) => name.split('-').slice(0, -1).join('-'));\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        this.remove(node);\n        node.classList.add(`${this.keyName}-${value}`);\n        return true;\n    }\n    remove(node) {\n        const matches = match(node, this.keyName);\n        matches.forEach((name) => {\n            node.classList.remove(name);\n        });\n        if (node.classList.length === 0) {\n            node.removeAttribute('class');\n        }\n    }\n    value(node) {\n        const result = match(node, this.keyName)[0] || '';\n        const value = result.slice(this.keyName.length + 1); // +1 for hyphen\n        return this.canAdd(node, value) ? value : '';\n    }\n}\nexport default ClassAttributor;\n","import Attributor from './attributor';\nfunction camelize(name) {\n    const parts = name.split('-');\n    const rest = parts\n        .slice(1)\n        .map((part) => part[0].toUpperCase() + part.slice(1))\n        .join('');\n    return parts[0] + rest;\n}\nclass StyleAttributor extends Attributor {\n    static keys(node) {\n        return (node.getAttribute('style') || '').split(';').map((value) => {\n            const arr = value.split(':');\n            return arr[0].trim();\n        });\n    }\n    add(node, value) {\n        if (!this.canAdd(node, value)) {\n            return false;\n        }\n        // @ts-ignore\n        node.style[camelize(this.keyName)] = value;\n        return true;\n    }\n    remove(node) {\n        // @ts-ignore\n        node.style[camelize(this.keyName)] = '';\n        if (!node.getAttribute('style')) {\n            node.removeAttribute('style');\n        }\n    }\n    value(node) {\n        // @ts-ignore\n        const value = node.style[camelize(this.keyName)];\n        return this.canAdd(node, value) ? value : '';\n    }\n}\nexport default StyleAttributor;\n","import Registry from '../registry';\nimport Scope from '../scope';\nimport Attributor from './attributor';\nimport ClassAttributor from './class';\nimport StyleAttributor from './style';\nclass AttributorStore {\n    constructor(domNode) {\n        this.attributes = {};\n        this.domNode = domNode;\n        this.build();\n    }\n    attribute(attribute, value) {\n        // verb\n        if (value) {\n            if (attribute.add(this.domNode, value)) {\n                if (attribute.value(this.domNode) != null) {\n                    this.attributes[attribute.attrName] = attribute;\n                }\n                else {\n                    delete this.attributes[attribute.attrName];\n                }\n            }\n        }\n        else {\n            attribute.remove(this.domNode);\n            delete this.attributes[attribute.attrName];\n        }\n    }\n    build() {\n        this.attributes = {};\n        const blot = Registry.find(this.domNode);\n        if (blot == null) {\n            return;\n        }\n        const attributes = Attributor.keys(this.domNode);\n        const classes = ClassAttributor.keys(this.domNode);\n        const styles = StyleAttributor.keys(this.domNode);\n        attributes\n            .concat(classes)\n            .concat(styles)\n            .forEach((name) => {\n            const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n            if (attr instanceof Attributor) {\n                this.attributes[attr.attrName] = attr;\n            }\n        });\n    }\n    copy(target) {\n        Object.keys(this.attributes).forEach((key) => {\n            const value = this.attributes[key].value(this.domNode);\n            target.format(key, value);\n        });\n    }\n    move(target) {\n        this.copy(target);\n        Object.keys(this.attributes).forEach((key) => {\n            this.attributes[key].remove(this.domNode);\n        });\n        this.attributes = {};\n    }\n    values() {\n        return Object.keys(this.attributes).reduce((attributes, name) => {\n            attributes[name] = this.attributes[name].value(this.domNode);\n            return attributes;\n        }, {});\n    }\n}\nexport default AttributorStore;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\n// Shallow object comparison\nfunction isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n        return false;\n    }\n    // @ts-ignore\n    for (const prop in obj1) {\n        // @ts-ignore\n        if (obj1[prop] !== obj2[prop]) {\n            return false;\n        }\n    }\n    return true;\n}\nclass InlineBlot extends ParentBlot {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.attributes = new AttributorStore(this.domNode);\n    }\n    static formats(domNode, scroll) {\n        const match = scroll.query(InlineBlot.blotName);\n        if (match != null &&\n            domNode.tagName === match.tagName) {\n            return undefined;\n        }\n        else if (typeof this.tagName === 'string') {\n            return true;\n        }\n        else if (Array.isArray(this.tagName)) {\n            return domNode.tagName.toLowerCase();\n        }\n        return undefined;\n    }\n    format(name, value) {\n        if (name === this.statics.blotName && !value) {\n            this.children.forEach((child) => {\n                if (!(child instanceof InlineBlot)) {\n                    child = child.wrap(InlineBlot.blotName, true);\n                }\n                this.attributes.copy(child);\n            });\n            this.unwrap();\n        }\n        else {\n            const format = this.scroll.query(name, Scope.INLINE);\n            if (format == null) {\n                return;\n            }\n            if (format instanceof Attributor) {\n                this.attributes.attribute(format, value);\n            }\n            else if (value &&\n                (name !== this.statics.blotName || this.formats()[name] !== value)) {\n                this.replaceWith(name, value);\n            }\n        }\n    }\n    formats() {\n        const formats = this.attributes.values();\n        const format = this.statics.formats(this.domNode, this.scroll);\n        if (format != null) {\n            formats[this.statics.blotName] = format;\n        }\n        return formats;\n    }\n    formatAt(index, length, name, value) {\n        if (this.formats()[name] != null ||\n            this.scroll.query(name, Scope.ATTRIBUTE)) {\n            const blot = this.isolate(index, length);\n            blot.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    optimize(context) {\n        super.optimize(context);\n        const formats = this.formats();\n        if (Object.keys(formats).length === 0) {\n            return this.unwrap(); // unformatted span\n        }\n        const next = this.next;\n        if (next instanceof InlineBlot &&\n            next.prev === this &&\n            isEqual(formats, next.formats())) {\n            next.moveChildren(this);\n            next.remove();\n        }\n    }\n    replaceWith(name, value) {\n        const replacement = super.replaceWith(name, value);\n        this.attributes.copy(replacement);\n        return replacement;\n    }\n    update(mutations, context) {\n        super.update(mutations, context);\n        const attributeChanged = mutations.some((mutation) => mutation.target === this.domNode && mutation.type === 'attributes');\n        if (attributeChanged) {\n            this.attributes.build();\n        }\n    }\n    wrap(name, value) {\n        const wrapper = super.wrap(name, value);\n        if (wrapper instanceof InlineBlot) {\n            this.attributes.move(wrapper);\n        }\n        return wrapper;\n    }\n}\nInlineBlot.allowedChildren = [InlineBlot, LeafBlot];\nInlineBlot.blotName = 'inline';\nInlineBlot.scope = Scope.INLINE_BLOT;\nInlineBlot.tagName = 'SPAN';\nexport default InlineBlot;\n","import Attributor from '../attributor/attributor';\nimport AttributorStore from '../attributor/store';\nimport Scope from '../scope';\nimport LeafBlot from './abstract/leaf';\nimport ParentBlot from './abstract/parent';\nimport InlineBlot from './inline';\nclass BlockBlot extends ParentBlot {\n    constructor(scroll, domNode) {\n        super(scroll, domNode);\n        this.attributes = new AttributorStore(this.domNode);\n    }\n    static formats(domNode, scroll) {\n        const match = scroll.query(BlockBlot.blotName);\n        if (match != null &&\n            domNode.tagName === match.tagName) {\n            return undefined;\n        }\n        else if (typeof this.tagName === 'string') {\n            return true;\n        }\n        else if (Array.isArray(this.tagName)) {\n            return domNode.tagName.toLowerCase();\n        }\n    }\n    format(name, value) {\n        const format = this.scroll.query(name, Scope.BLOCK);\n        if (format == null) {\n            return;\n        }\n        else if (format instanceof Attributor) {\n            this.attributes.attribute(format, value);\n        }\n        else if (name === this.statics.blotName && !value) {\n            this.replaceWith(BlockBlot.blotName);\n        }\n        else if (value &&\n            (name !== this.statics.blotName || this.formats()[name] !== value)) {\n            this.replaceWith(name, value);\n        }\n    }\n    formats() {\n        const formats = this.attributes.values();\n        const format = this.statics.formats(this.domNode, this.scroll);\n        if (format != null) {\n            formats[this.statics.blotName] = format;\n        }\n        return formats;\n    }\n    formatAt(index, length, name, value) {\n        if (this.scroll.query(name, Scope.BLOCK) != null) {\n            this.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    insertAt(index, value, def) {\n        if (def == null || this.scroll.query(value, Scope.INLINE) != null) {\n            // Insert text or inline\n            super.insertAt(index, value, def);\n        }\n        else {\n            const after = this.split(index);\n            if (after != null) {\n                const blot = this.scroll.create(value, def);\n                after.parent.insertBefore(blot, after);\n            }\n            else {\n                throw new Error('Attempt to insertAt after block boundaries');\n            }\n        }\n    }\n    replaceWith(name, value) {\n        const replacement = super.replaceWith(name, value);\n        this.attributes.copy(replacement);\n        return replacement;\n    }\n    update(mutations, context) {\n        super.update(mutations, context);\n        const attributeChanged = mutations.some((mutation) => mutation.target === this.domNode && mutation.type === 'attributes');\n        if (attributeChanged) {\n            this.attributes.build();\n        }\n    }\n}\nBlockBlot.blotName = 'block';\nBlockBlot.scope = Scope.BLOCK_BLOT;\nBlockBlot.tagName = 'P';\nBlockBlot.allowedChildren = [\n    InlineBlot,\n    BlockBlot,\n    LeafBlot,\n];\nexport default BlockBlot;\n","import LeafBlot from './abstract/leaf';\nclass EmbedBlot extends LeafBlot {\n    static formats(_domNode, _scroll) {\n        return undefined;\n    }\n    format(name, value) {\n        // super.formatAt wraps, which is what we want in general,\n        // but this allows subclasses to overwrite for formats\n        // that just apply to particular embeds\n        super.formatAt(0, this.length(), name, value);\n    }\n    formatAt(index, length, name, value) {\n        if (index === 0 && length === this.length()) {\n            this.format(name, value);\n        }\n        else {\n            super.formatAt(index, length, name, value);\n        }\n    }\n    formats() {\n        return this.statics.formats(this.domNode, this.scroll);\n    }\n}\nexport default EmbedBlot;\n","import Scope from '../scope';\nimport ContainerBlot from './abstract/container';\nimport ParentBlot from './abstract/parent';\nimport BlockBlot from './block';\nconst OBSERVER_CONFIG = {\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n};\nconst MAX_OPTIMIZE_ITERATIONS = 100;\nclass ScrollBlot extends ParentBlot {\n    constructor(registry, node) {\n        // @ts-ignore\n        super(null, node);\n        this.registry = registry;\n        this.scroll = this;\n        this.build();\n        this.observer = new MutationObserver((mutations) => {\n            this.update(mutations);\n        });\n        this.observer.observe(this.domNode, OBSERVER_CONFIG);\n        this.attach();\n    }\n    create(input, value) {\n        return this.registry.create(this, input, value);\n    }\n    find(node, bubble = false) {\n        const blot = this.registry.find(node, bubble);\n        if (!blot) {\n            return null;\n        }\n        if (blot.scroll === this) {\n            return blot;\n        }\n        return bubble ? this.find(blot.scroll.domNode.parentNode, true) : null;\n    }\n    query(query, scope = Scope.ANY) {\n        return this.registry.query(query, scope);\n    }\n    register(...definitions) {\n        return this.registry.register(...definitions);\n    }\n    build() {\n        if (this.scroll == null) {\n            return;\n        }\n        super.build();\n    }\n    detach() {\n        super.detach();\n        this.observer.disconnect();\n    }\n    deleteAt(index, length) {\n        this.update();\n        if (index === 0 && length === this.length()) {\n            this.children.forEach((child) => {\n                child.remove();\n            });\n        }\n        else {\n            super.deleteAt(index, length);\n        }\n    }\n    formatAt(index, length, name, value) {\n        this.update();\n        super.formatAt(index, length, name, value);\n    }\n    insertAt(index, value, def) {\n        this.update();\n        super.insertAt(index, value, def);\n    }\n    optimize(mutations = [], context = {}) {\n        super.optimize(context);\n        const mutationsMap = context.mutationsMap || new WeakMap();\n        // We must modify mutations directly, cannot make copy and then modify\n        let records = Array.from(this.observer.takeRecords());\n        // Array.push currently seems to be implemented by a non-tail recursive function\n        // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n        while (records.length > 0) {\n            mutations.push(records.pop());\n        }\n        const mark = (blot, markParent = true) => {\n            if (blot == null || blot === this) {\n                return;\n            }\n            if (blot.domNode.parentNode == null) {\n                return;\n            }\n            if (!mutationsMap.has(blot.domNode)) {\n                mutationsMap.set(blot.domNode, []);\n            }\n            if (markParent) {\n                mark(blot.parent);\n            }\n        };\n        const optimize = (blot) => {\n            // Post-order traversal\n            if (!mutationsMap.has(blot.domNode)) {\n                return;\n            }\n            if (blot instanceof ParentBlot) {\n                blot.children.forEach(optimize);\n            }\n            mutationsMap.delete(blot.domNode);\n            blot.optimize(context);\n        };\n        let remaining = mutations;\n        for (let i = 0; remaining.length > 0; i += 1) {\n            if (i >= MAX_OPTIMIZE_ITERATIONS) {\n                throw new Error('[Parchment] Maximum optimize iterations reached');\n            }\n            remaining.forEach((mutation) => {\n                const blot = this.find(mutation.target, true);\n                if (blot == null) {\n                    return;\n                }\n                if (blot.domNode === mutation.target) {\n                    if (mutation.type === 'childList') {\n                        mark(this.find(mutation.previousSibling, false));\n                        Array.from(mutation.addedNodes).forEach((node) => {\n                            const child = this.find(node, false);\n                            mark(child, false);\n                            if (child instanceof ParentBlot) {\n                                child.children.forEach((grandChild) => {\n                                    mark(grandChild, false);\n                                });\n                            }\n                        });\n                    }\n                    else if (mutation.type === 'attributes') {\n                        mark(blot.prev);\n                    }\n                }\n                mark(blot);\n            });\n            this.children.forEach(optimize);\n            remaining = Array.from(this.observer.takeRecords());\n            records = remaining.slice();\n            while (records.length > 0) {\n                mutations.push(records.pop());\n            }\n        }\n    }\n    update(mutations, context = {}) {\n        mutations = mutations || this.observer.takeRecords();\n        const mutationsMap = new WeakMap();\n        mutations\n            .map((mutation) => {\n            const blot = this.find(mutation.target, true);\n            if (blot == null) {\n                return null;\n            }\n            if (mutationsMap.has(blot.domNode)) {\n                mutationsMap.get(blot.domNode).push(mutation);\n                return null;\n            }\n            else {\n                mutationsMap.set(blot.domNode, [mutation]);\n                return blot;\n            }\n        })\n            .forEach((blot) => {\n            if (blot != null && blot !== this && mutationsMap.has(blot.domNode)) {\n                blot.update(mutationsMap.get(blot.domNode) || [], context);\n            }\n        });\n        context.mutationsMap = mutationsMap;\n        if (mutationsMap.has(this.domNode)) {\n            super.update(mutationsMap.get(this.domNode), context);\n        }\n        this.optimize(mutations, context);\n    }\n}\nScrollBlot.blotName = 'scroll';\nScrollBlot.defaultChild = BlockBlot;\nScrollBlot.allowedChildren = [BlockBlot, ContainerBlot];\nScrollBlot.scope = Scope.BLOCK_BLOT;\nScrollBlot.tagName = 'DIV';\nexport default ScrollBlot;\n","import Scope from '../scope';\nimport LeafBlot from './abstract/leaf';\nclass TextBlot extends LeafBlot {\n    constructor(scroll, node) {\n        super(scroll, node);\n        this.text = this.statics.value(this.domNode);\n    }\n    static create(value) {\n        return document.createTextNode(value);\n    }\n    static value(domNode) {\n        return domNode.data;\n    }\n    deleteAt(index, length) {\n        this.domNode.data = this.text =\n            this.text.slice(0, index) + this.text.slice(index + length);\n    }\n    index(node, offset) {\n        if (this.domNode === node) {\n            return offset;\n        }\n        return -1;\n    }\n    insertAt(index, value, def) {\n        console.log({\n            name: 'insertAt',\n            index,\n            value\n        });\n        if (def == null) {\n            this.text = this.text.slice(0, index) + value + this.text.slice(index);\n            this.domNode.data = this.text;\n        }\n        else {\n            super.insertAt(index, value, def);\n        }\n    }\n    length() {\n        return this.text.length;\n    }\n    optimize(context) {\n        super.optimize(context);\n        this.text = this.statics.value(this.domNode);\n        if (this.text.length === 0) {\n            this.remove();\n        }\n        else if (this.next instanceof TextBlot && this.next.prev === this) {\n            this.insertAt(this.length(), this.next.value());\n            this.next.remove();\n        }\n    }\n    position(index, _inclusive = false) {\n        return [this.domNode, index];\n    }\n    split(index, force = false) {\n        if (!force) {\n            if (index === 0) {\n                return this;\n            }\n            if (index === this.length()) {\n                return this.next;\n            }\n        }\n        const after = this.scroll.create(this.domNode.splitText(index));\n        this.parent.insertBefore(after, this.next || undefined);\n        this.text = this.statics.value(this.domNode);\n        return after;\n    }\n    update(mutations, _context) {\n        if (mutations.some((mutation) => {\n            return (mutation.type === 'characterData' && mutation.target === this.domNode);\n        })) {\n            this.text = this.statics.value(this.domNode);\n        }\n    }\n    value() {\n        return this.text;\n    }\n}\nTextBlot.blotName = 'text';\nTextBlot.scope = Scope.INLINE_BLOT;\nexport default TextBlot;\n"],"names":["root","factory","exports","module","define","amd","self","Scope","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ParchmentError","Error","constructor","message","super","this","name","Registry","attributes","classes","tags","types","static","node","bubble","blots","has","find","parentNode","create","scroll","input","match","query","blotClass","Node","nodeType","TEXT_NODE","blot","set","domNode","scope","Text","text","block","inline","HTMLElement","getAttribute","split","some","tagName","register","definitions","length","map","d","blotName","attrName","keyName","className","Array","isArray","toUpperCase","forEach","tag","WeakMap","ShadowBlot","prev","next","parseInt","toString","document","createElement","indexOf","classList","add","statics","attach","clone","cloneNode","detach","parent","removeChild","deleteAt","index","isolate","remove","formatAt","wrap","format","insertAt","def","ref","insertBefore","undefined","target","offset","children","optimize","_context","requiredContainer","replaceWith","replacement","_force","update","_mutations","wrapper","appendChild","makeAttachedBlot","e","from","childNodes","child","replaceChild","ParentBlot","uiNode","build","other","attachUI","uiClass","setAttribute","firstChild","head","tail","append","nodes","rest","slice","at","iterator","cur","contains","refNode","curNode","ret","inclusive","callback","forEachAt","startNode","curIndex","curLength","Math","min","reduce","memo","push","filter","reverse","err","childLength","descendant","criteria","descendants","Number","MAX_VALUE","lengthLeft","childIndex","concat","enforceAllowedChildren","done","allowedChildren","splitAfter","unwrap","childBlot","refBlot","refDomNode","nextSibling","moveChildren","targetParent","context","defaultChild","path","position","force","after","_length","mutations","addedNodes","removedNodes","mutation","type","body","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","sort","a","b","DOCUMENT_POSITION_FOLLOWING","ContainerBlot","checkMerge","LeafBlot","_domNode","_inclusive","Attributor","options","attributeBit","whitelist","item","canAdd","_node","replace","removeAttribute","prefix","join","camelize","parts","part","trim","style","attribute","keys","styles","attr","copy","move","values","InlineBlot","toLowerCase","formats","obj1","obj2","isEqual","BlockBlot","_scroll","OBSERVER_CONFIG","characterData","characterDataOldValue","childList","subtree","ScrollBlot","registry","observer","MutationObserver","observe","disconnect","mutationsMap","records","takeRecords","pop","mark","markParent","delete","remaining","i","previousSibling","grandChild","TextBlot","createTextNode","data","console","log","splitText"],"sourceRoot":""}